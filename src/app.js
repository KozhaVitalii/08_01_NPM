// 1. Дефолтный импорт/экспорт (включая внешнюю библиотеку joi)

// import validatePasword from '../js/validate-password'; // validatePasword - это название локальной переменной (название 
// какое угодно может быть).
// console.log(validatePasword);
// console.log(validatePasword('passwordIstrue'));

// Далее передаю по дифолту 3 функции:

// import appService from '../js/api-service';

// console.log(appService); // в итоге будет объект с тремя этими функциями

// А теперь затягиваем внешнюю библиотеку и вызываем функцию для валидации пароля:
import validatePasword from '../js/validate-password';

console.log(validatePasword('e2efd')); // свалидировал пароль без ошибки т.к. отвечает требованию от 3 до 10 символов
console.log(validatePasword('e2efdfdfdfdfdf')); // свалидировал с ошибкой т.к. не отвечает требованию от 3 до 10 символов

// 2. Именованный импорт/экспорт
// Для именнованного экспорта необходимо в {} указать именна сущностей которые мы хотим передать и они должны совпадать
// при этом мы можем указать только одну или две переменные не обязательно все три. К тому же можем передавать и любые
// другие переменные

// import {
//     fetchAllUsers,
//     fetchUserById,
//     updateUserById,
//     x as value,
//     y as name
// } from '../js/api-service';

// console.log(fetchAllUsers);
// console.log(fetchUserById);
// console.log(updateUserById);
// console.log(value);
// console.log(name);

// От дефолтного отличается синтаксисом и тем что можно экспортировать много именованных сущностей. И в {} передаем
// точно имя переменной которую передаем из исходного файла.

// При импорте мы можем переназывать передаваемую переменную в какое то более подходящее название, см. пример с
// переменной х


// 3. Ещё один вариант импорта/экспорта называется "импорт пространства имен".
// Говорим я хочу забрать все из моего модуля api-service:

// import * as apiService from '../js/api-service';
// console.log(apiService);


// Пример:
// У нас есть файл allFunction.js, где мы пишем и храним все наши функции,  примеру уже есть несколько:
// const value = 100;

// function add(a, b) {
//     return a + b;
// }

// function sum(a, b) {
//     return a * b + value;
// }
// Если нам необходимо передать несколько функций, то мы говорим:
// export { add, sum };

// Если только одну то пишем:     
// export function add(a, b) {
//     return a + b;
// }
    
// Предположим у нас есть js файл allFunction.js, в котором мы храним все наши функции, для текущего файла нам необходимо достать 
// из него две функции для переиспользования.Можем импортировать так:
// import { sum as fnSum, add } from './allFunction.js' // на примере пердаваемой функции sum мы можем её переименовать
// console.log(fnSum(2, 3)); // вызываем(используем) функцию уже там где нам это необходимо
// console.log(fnSum(7, 9));
// Есть правило, если мы импортируем более 5 функций, объектов, то есть смысл передать всё, а не перечислять списком
// Для импорта всего содержимого мы прописываем так:
import * as functionData from './allFunction.js' // передаем все функции, здесь нам уже не надо идти в исходный файл и 
// прописывать условия в export {}, просто забираем всё.
// console.log(functionData.add); // если передаем все функции как массив объектов, то вызываем функцию (как объект) уже
// через точку 

// И здесь уже необходимо смотреть.Если необходимо из модуля забрать несколько сущностей(переменных), то тогда именнованный
// импорт, если нужны все сущности из модуля, то тогда лучше через "импорт пространства имен".

// Можно совмещать и дефолтный (один объект или переменную) и именованный экспорт (другой объект или их массив) из одного файла, 
// но на практике не часто используется

// Все это были примеры связанные с подключением модулей внутри нашего проекта.
// Окей, а что если мы хотим использовать подключаемые внешние библиотеки? Смотрим на примере файла validate-password.js

// затягиваем библиотеку shortid:

import { addUser } from '../js/api-service';

addUser('Mango');

// В итоге для свойства name получаем имя Mango, а для свойства id благодаря библиотеке shortid сгенерился уникальный
// Id 'O8DV_076x'

// По сути мы построили дерево зависимостей: когда браузер заходит в наш html файл он видет подключенный
// < script type = "module" src = "app.js" ></script > - это наш основной файл js. Этот app.js есть точкой входа(см.как
// подключали parcel), или корневым файлом всего проекта.Потом браузер смотрит на все импорты, которые подключены в
// app.js, если указанные в нем модули где - то(откуда - то) заимпортированы(используется), а в этих модулях есть ещё и
// заимпортированы внешние библиотеки.В итоге браузер рисует ветки в нашем случае их 2:

// index.html > app.js > api - service > lib 'shortid'
// index.html > app.js > validate-password > lib 'joi'

// После чего браузер через parcel преобразовует и собирает это все в один большой js файл, который помещает в папку "dist"
// в основной файл js, который будет читать любой браузер. Так работает bundler (бандл). Для того чтобы собрать это все
// в продакшн мы в терминале запускаем npm run build(мы в нашем файле манифесте package.json, добавляли
// скрипт "build": "parcel build" - который говорит сделай нам продакшн версию).Он нам все это билдит и на выходе мы
// получаем только один js файл (примерно по аналогии с тем как собирется scss). Этот файл только для браузера, разработчик
// его не юзает ни в коем случае. В него собирается код библиотек и т.д. и только в конец наш код. 